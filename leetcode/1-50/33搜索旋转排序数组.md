### 解题思路
基本上还是二分查找法。
难点
1，多种情况。
2，边界问题。

数组是两个有序序列，一个从k到n-1，一个从0到k-1； 而且k>k-1的。

如果target > mid
mid有两种情况，一种是在k到n-1中。
             一种是在0到k-1中。
怎么判断呢？  就是mid是否大于k。如果大于k，肯定在k到n-1中。
                            小于，就在0到k-1中。
mid在k到n-1之间
k ，k+1， k+2 。。。 n-1，0，1，2。。。k-1

      mid < target            mid < target
所以这时，  left = mid + 1；

mid在0到k-1之间
k ，k+1， k+2 。。。 n-1，0，1，2。。。k-1

                            mid < target
这时，又有两种情况，一个是mid到k-1之间。
                 另外一个k到n-1之间。

所以在比较一下   target和k到大小。
如果大于target>=k 那么right = mid - 1;
如果target < k  , left = mid + 1;

反之target<mid的时候。同理。反正很烧脑。。。

等于mid的时候直接返回，

left>right就退出，没有找到。



### 代码

```java
class Solution {
    public int search(int[] nums, int target) {

        int left = 0,right = nums.length-1,mid;
        int k;
        if(target>=nums[0]){
            k = 1;
        }else{
            k = 0;
        }

        //两个有序队列
        //k到n-1 和 0到k-1；

        //mid可以在k，n-1中或者0，k-1中

        while(right>=left){
            mid = (right+left)/2;

            if(target >nums[mid]){
                //如果target>=nums[k]
                if(k == 1){
                    //1，在k-n-1中。
                    if(nums[mid] >= nums[0]){
                        left = mid + 1;
                    }
                    //2，在0，k-1中。
                    else{
                        right = mid - 1;
                    }
                }else{
                    //1，在k-n-1中。不存在。
//                    if(nums[k]>nums[mid]){
//                        left = mid+1;
//                    }
                    //2，在0，k-1中。
                    left = mid + 1 ;
                }

            }else if(target < nums[mid]){

                //如果target>=nums[k]
                if(k == 1){
                    //1，在k-n-1中。
                    if(nums[mid] >= nums[0]){
                        right = mid - 1;
                    }
                    //2，在0，k-1中。target  > k,target < mid   mid < k不存在。
//                    else{
//                        right = mid -1;
//                    }
                }else{
                    //1，在k-n-1中。不存在。
                    if(nums[mid] >= nums[0]){
                        left = mid+1;
                    }else {
                        //2，在0，k-1中。
                        right = mid-1;
                    }
                }
            }else{
                return mid;
            }

        }

        return -1;
    }
}
```