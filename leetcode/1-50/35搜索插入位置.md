### 解题思路
基本上二分查找法。但是增加了难度，没找到的，怎么确认返回值。

1，考虑三种极端情况，
1，没有元素，直接返回0.
2，目标小于0号元素，直接返回0.
3，目标大于最后一个元素，直接返回数组长度。
2，开始二分查找法：
1，找到的情况，直接返回mid。
2，找不到的情况，关键地方，两种，一种最后一次比较大于目标，需要right左移，如果左移之后，小于left了。所以此时，left左侧都是比target小的。此时应该mid = right=left ，左移一位，还比target小，只能是当前的mid位值。
第二种，最后一次比较，元素小于target。left右移，右移之后left大于right。且，也是原mid = left = right，right之后的元素大于target，右移一位也就是大于target，所以就是当前mid+1；


### 代码

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        if (nums.length <= 0) {
            return 0;
        }
        if(target < nums[0]){
            return 0;
        }

        if(target>nums[nums.length - 1]){
            return nums.length;
        }

        int left = 0, right = nums.length - 1;
        int mid;
        int re = 0;
        while (right >= left) {
            mid = left + (right - left) / 2;

            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {

                right = mid - 1;
                re = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
                re = mid+1;
            }
        }

        return re;
    }
}
```