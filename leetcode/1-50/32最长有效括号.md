### 解题思路
首先有个容器，一个是"("的栈，用于和‘）’左匹配用。
另外一个是已经成对的括号容器。

然后就是循环，
    1，每次遇到'('入栈，
    2，每次遇到‘（’，开始判断
        1，如果栈空，直接continue
        2，如果栈不为空。
            开始出栈。
            计算两个括号的距离，currNumber。
            然后遍历已经成对的括号容器。
                1，如果元素，在当前的括号中间，直接去掉。
                2，如果元素的‘）’和当前的‘（’差挨着，currNumber就加上元素的两个括号差。
                3，直到不挨着时候退出。
            判断currNumber是否是最长的字符长度。
            把当前括号，也插入到已经成对的括号中。

### 代码

```java
class Solution {
    public int longestValidParentheses(String s) {
        if (s.length() <= 0) {
            return 0;
        }

        Stack<Map<Character,Integer>> stack = new Stack<>();
        char[] str = s.toCharArray();

        int longestNumber = 0;
        int currNumber;

        List<Integer[]> pre = new ArrayList<>();

        for (int i = 0; i < str.length; i++) {
            currNumber = 0;

            if (str[i] == '(') {
                Map<Character,Integer> map = new HashMap<>();
                map.put('(',i);
                stack.push(map);
                continue;
            }

            //否则是')'的时候，就需要匹配。
            // 没有成对括号时候，下一次循环。
            if (stack.isEmpty()) {
                continue;
            }

            //如果有成对括号。
            Map<Character,Integer> currMap =  stack.pop();

            //弹出元素，记录开始和结束位置。放入pre队列。以供挨着的计算
            Integer[] pair = new Integer[2];
            pair[0] = currMap.get('(');
            pair[1] = i;
            currNumber = pair[1] + 1 - pair[0];
            //把两个括号之间的pre元素都去掉。
            if(pair[1] - pair[0] > 1){
                while(!pre.isEmpty()){
                    Integer[] currPair = pre.remove(pre.size()-1);
                    //属于括号之间的，pop掉
                    if(currPair[0] >pair[0] && currPair[1] < pair[1]){
                        continue;
                    }
                    //不属于括号之间的还加回去。并且退出。
                    else{
                        pre.add(currPair);
                        break;
                    }
                }
            }

            //开始计算是否挨着，如果挨着，那么增加长度。
            int currStart = pair[0];
            for(int k = pre.size()-1; k >= 0;k--){
                Integer[] currPair = pre.get(k);
                if(currStart - currPair[1] == 1){
                    currStart = currPair[0];
                    currNumber = currNumber + (currPair[1]+1-currPair[0]);
                }else{
                    break;
                }
            }

            //判断是否大于最长，如果大于。赋值给最长。
            if(currNumber>longestNumber){
                longestNumber = currNumber;
            }
            //加入到pre队列。
            pre.add(pair);

        }

        return longestNumber;
    }
}
```